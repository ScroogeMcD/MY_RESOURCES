## Apache Flink 

### JobManager vs TaskManager   
  * JobManager is like the master node
  * TaskManagers are like worker nodes
  * Each TaskManager can have one or more slots

### [Join processing in Flink](https://flink.apache.org/news/2015/03/13/peeking-into-Apache-Flinks-Engine-Room.html)
We will be discussing only equi-joins here. Assume there are two datasets R and S.    

In a **standalone join**, the simplest approach would be to have two nested for-loops, wherein in the first loop, iterate on R, and then for each row in R, iterate on all rows of S. The time complexity of this would be qaudratic of O(N<sup>2</sup>).

In **distributed systems**,joins are typically processed in two steps :   
* **STEP 01 : Ship Strategy** : The data of both inputs R and S, is distributed across all parallel instances that participate in the join.   
  * **1.1 Repartition - Repartition strategy** :    
  Partition both datasets R and S on the join key attribute, using the same partitioning function. Each partition is assigned to exactly one parallel join instance, and all data of that partition is sent to its associated instance. This ensures that all data that share the same join key are available on the same parallel instance, and can be locally joined. The cost of this strategy is full shuffle of both the datasets over the network.
  * **1.2 Broadcast - Forward strategy** :    
  Send one complete dataset R to each parallel instance, that holds a partition of the other dataset S. The cost depends on the size of R and the number of parallel instances it is sent to, but does not depend on size of S, since S is not moved around.
* **STEP 02 : Local Strategy** :Each parallel instance performs a standard standalone join algorithm on its local partition of the overall data.

### Stream processing terminologies
 * **Event time** : time at which an event actually <i>occurred</i> (valid_time)
 * **Processing time** : time at which events were <i>observed</i> in the system (transaction_time or knowledge_time)
 * **Windowing** : chopping up data into finite pieces along temporal boundaries
 * **Data processing - unbounded data - using batch engine** :
   * fixed window
   * sessions
 * **Data processing - unbounded data - streaming**
   * time agnostic : ex. filtering, inner-join
   * approximation : approximation algorithms like approximate top-N, streaming K-means
   * windowing by processing time : 
   * windowing by event time
 * **Watermarks** : A watermark is a notion of input completeness with respect to event times. A watermark with a value of time X makes the statement: "all input data with event times less than X have been observed". As such, watermarks act as a metric of progress when observing an unbounded data source with no known end.   
 * **Triggers** :A trigger is a mechanism for declaring when the output for a window should be materialized relative to some external signals. Triggers provide flexibility in choosing when outputs should be emitted.
 * 
