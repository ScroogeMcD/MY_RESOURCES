# Java Threads and Concurrency

## Memory regions :
  * Heap (shared across threads)
    * Objects
    * Class members
    * Static Variables
  * Stack (separate for each thread)
    * local primitive types
    * local references

## Guarding critical section in JVM

* **synchronized** keyword
  * declare a method synchronized : Synchronized - monitor
    ```java
    public class ThreadTest {
      public synchronized void method1() {...}
      public synchronized void method2() {...}
    }
    ```
    Now if we create an object *obj1* of this class, and in two different threads *t1* and *t2*, try to invoke ```obj1.method1()``` and ```obj1.method2()```, 
    unless one thread exits say method1(), the other thread cannot enter method2(). This is because synchronized acquires lock at the object level.
* declare a block synchronized : Synchronized - block
  Here we first need to create an object to synchronize on, which will serve as a lock.
  ```java
  public class ClassWithCriticalSections{
    Object lockingObject = new Object();
    
    public void method1(){
      synchronized(lockingObject){
        // critical section
      }
    }
  }
  ```
  
  The synchronized method example given above is equivalent to the following synchronized block example :
  ```java
   public class ClassWithCriticalSections{
   
     public void method1(){
      synchronized(this){
        ...
      }
     }
     
     public void method2() {
      synchronized(this){
        ...
      }
     }
   }
  ```
  
  A synchronized block is **Reentrant**, i.e. a thread cannot prevent itself from entering a critical section. Ex.: 
  ```java
  public class ClassWithCriticalSections{
    public synchronized method1() {
      method2();
    }
    
    public synchronized method2() {
      ...
    }
  }
  ```
  In the above case, a thread T1 while accessing method1() can also enter method2() since it is already holding the lock.
  
  ## Atomic operations, volatile
  * all reference assignments are atomic
  * all assignments to primitive types are atomic, except *long* and *double*
  * Reading or writing to long and double values are not atomic. This is because it involves reading from or writing to first 32 bit, and then the second 32 bit.
  * Declaring a long or a double as **volatile** makes them atomic, because the JVM ensures that a write to a volatile field happens-before every subsequent read of that field.
