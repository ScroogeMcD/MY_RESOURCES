# System Design questions
## Contents
* [Design a URL shortening service](#design-a-url-shortening-service)
* [Design a unique Id generator](#design-a-unique-id-generator)
* [Design an API rate limiter](#design-an-api-rate-limiter)
* [Design typeahead suggestion](#design-typeahead-suggestion)
* [Design a web crawler](#design-a-web-crawler)
* [Design a chat service](#design-a-chat-service)

**Follow this order** : 
* **Functional Requirements** : analytics apart from other things
* **Non-functional requirements** : Availability, latency, etc
* **Read Heavy vs Write Heavy system**
* **Estimations**
* **Deep Dive on algorithm**
  - APIs  :
    - what data exchange format to use: external-> JSON, internal->gRPC and protobuf
  - design : 
    - Is a message queue required here ? 
    - SQL vs NoSQL etc
    - Bloom Filters, Streams, Stateless vs Stateful, minimizing network calls, LSM DBs etc., semaphores, locks etc
* **Data partition and replication** : consistent hashing, sharding etc
* **Analytics APIs** : using CDC probably
* Data purging
* Metrics and monitoring, rate limiting
* Security

## Design a URL shortening service
Key points : 
- system will be read-heavy
- a base64 encoding, with 6 characters in the shortened URL can support 64^6 =~ 68 billion URLs
- Idea 1 : 
  - Hash the long URL to generate the short URL
  - The hash would be around 128 bits, or 16 bytes, of which we need only 6 bytes, so multiple URLs can get same short URL, leading to collisions
- Idea 2 : 
  - Pre-generate all the possible 6 byte permutations of Base 64, and randomly assign them IDs. Store the IDs and corresponding ShortURL in DB
  - When a request for shortening a URL comes, assign it the next unassigned short URL, and add the long URL in the DB corresponding to this short URL
  - This prevents two Long URLs from getting the same short URL
  - To prevent same long URL from getting multiple short URLs, everytime a createShortURL API is invoked, check if the long URL already exists in the DB.
    Since this will be a costly operation, as our key is short URL and not long URL, we can maintain a **Bloom Filter** of already added long URLs.
    If bloom filter returns that a long URL is not added yet, it is 100% true, however if it says a long URL is present, we need to then check the DB, since
    bloom filters can return false positives.
- Cache (with LRU eviction) the short URLs
- Add analytics through CDC on the DB
- Sharding
  - based onn first letter of short URLs will lead to unbalances shards
  - use consistent hashing, to split the short URL set across multiple DB Servers based on their hash
- If required have keep-alive times for each entry, so that they can be purged after some time.


## Design a unique Id generator

## Design an API rate limiter

## Design typeahead suggestion

## Design a web crawler

## Design a chat service
